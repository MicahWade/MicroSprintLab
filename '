import time
import pynvim


def drawFloatingWindowWithTimer(text_lines, timeout_sec):
    nvim = pynvim.attach("socket", path="/tmp/nvim")

    buf = nvim.api.create_buf(False, True)
    nvim.api.buf_set_lines(buf, 0, -1, False, text_lines)

    width = max(len(line) for line in text_lines) + 2 if text_lines else 10
    height = len(text_lines) if text_lines else 1

    screen_width = nvim.api.get_option("columns")
    screen_height = nvim.api.get_option("lines")

    row = (screen_height - height) // 2
    col = (screen_width - width) // 2

    opts = {
        "relative": "editor",
        "width": width,
        "height": height,
        "row": row,
        "col": col,
        "style": "minimal",
        "border": "single",
    }

    win = nvim.api.open_win(buf, True, opts)

    nvim.api.buf_set_keymap(
        buf, "n", "q", ":close<CR>", {"nowait": True, "noremap": True, "silent": True}
    )
    nvim.api.buf_set_keymap(
        buf,
        "n",
        "<ESC>",
        ":close<CR>",
        {"nowait": True, "noremap": True, "silent": True},
    )

    nvim.exec_lua("""
    function ClosePopup(win_id)
        if vim.api.nvim_win_is_valid(win_id) then
        vim.api.nvim_win_close(win_id, true)
        end
    end
    """)

    nvim.command(f"""
    function! ClosePopupWrapper(timer_id)
      lua ClosePopup({win.handle})
      call timer_stop(a:timer_id)
    endfunction
    """)

    nvim.call("timer_start", int(timeout_sec * 1000), "ClosePopupWrapper")


def displayFullscreenTextWithTimer(text_lines, timeout_sec):
    nvim = pynvim.attach("socket", path="/tmp/nvim")
    buf = nvim.api.create_buf(False, True)
    nvim.api.buf_set_lines(buf, 0, -1, False, text_lines)
    width = max(len(line) for line in text_lines) + 2 if text_lines else 10
    height = len(text_lines) if text_lines else 1
    screen_width = nvim.api.get_option("columns")
    screen_height = nvim.api.get_option("lines")
    opts = {
        "relative": "editor",
        "width": screen_width,
        "height": screen_height,
        "row": 0,
        "col": 0,
        "style": "minimal",
        "border": "single",
    }
    win = nvim.api.open_win(buf, True, opts)
    nvim.api.buf_set_keymap(
        buf, "n", "q", ":close<CR>", {"nowait": True, "noremap": True, "silent": True}
    )
    nvim.api.buf_set_keymap(
        buf,
        "n",
        "<ESC>",
        ":close<CR>",
        {"nowait": True, "noremap": True, "silent": True},
    )
    nvim.exec_lua("""
    function ClosePopup(win_id)
        if vim.api.nvim_win_is_valid(win_id) then
            vim.api.nvim_win_close(win_id, true)
        end
    end
    """)
    nvim.command(f"""
    function! ClosePopupWrapper(timer_id)
        lua ClosePopup({win.handle})
        call timer_stop(a:timer_id)
    endfunction
    """)
    nvim.call("timer_start", int(timeout_sec * 1000), "ClosePopupWrapper")


def openFileInSingleTab(file_path):
    nvim = pynvim.attach("socket", path="/tmp/nvim")

    all_tabs = nvim.api.list_tabpages()
    current_tab = nvim.api.get_current_tabpage()

    for tab in all_tabs:
        if tab != current_tab:
            nvim.api.tabpage_close(tab)

    win = nvim.api.get_current_win()
    nvim.command(f"edit {file_path}")
    nvim.api.set_current_tabpage(current_tab)


def fullscreenCountdownWithText(text, seconds):
    nvim = pynvim.attach("socket", path="/tmp/nvim")
    buf = nvim.api.create_buf(False, True)
    screen_width = nvim.api.get_option("columns")
    screen_height = nvim.api.get_option("lines")
    opts = {
        "relative": "editor",
        "width": screen_width,
        "height": screen_height,
        "row": 0,
        "col": 0,
        "style": "minimal",
        "border": "single",
    }
    win = nvim.api.open_win(buf, True, opts)
    nvim.api.buf_set_keymap(
        buf,
        "n",
        "<CR>",
        ":lua _close_countdown_popup()<CR>",
        {"nowait": True, "noremap": True, "silent": True},
    )
    nvim.api.buf_set_keymap(
        buf,
        "n",
        "q",
        ":lua _close_countdown_popup()<CR>",
        {"nowait": True, "noremap": True, "silent": True},
    )
    nvim.api.buf_set_keymap(
        buf,
        "n",
        "<ESC>",
        ":lua _close_countdown_popup()<CR>",
        {"nowait": True, "noremap": True, "silent": True},
    )
    nvim.exec_lua("""
    vim.g.countdown_break = false
    function _close_countdown_popup()
        vim.g.countdown_break = true
    end
    """)
    for remaining in range(seconds, 0, -1):
        nvim.api.buf_set_lines(
            buf, 0, -1, False, [str(text), f"Countdown: {remaining}"]
        )
        if nvim.exec_lua("return vim.g.countdown_break"):
            break
        time.sleep(1)
    nvim.api.win_close(win, True)
    return nvim.exec_lua("return vim.g.countdown_break")


def displayTextWait(text_lines):
    if isinstance(text_lines, str):
        text_lines = text_lines.splitlines() or [text_lines]
    elif isinstance(text_lines, (list, tuple)):
        text_lines = [str(line) for line in text_lines]
    else:
        raise TypeError("text_lines must be a string or list/tuple of strings")

    nvim = pynvim.attach("socket", path="/tmp/nvim")

    current_tab = nvim.api.get_current_tabpage()
    all_tabs = nvim.api.list_tabpages()
    for tab in all_tabs:
        if tab != current_tab:
            nvim.api.tabpage_close(tab)

    win = nvim.api.get_current_win()
    prev_buf = nvim.api.get_current_buf()

    buf = nvim.api.create_buf(False, True)
    nvim.api.buf_set_lines(buf, 0, -1, False, text_lines)

    nvim.api.buf_set_option(buf, "bufhidden", "hide")
    nvim.api.buf_set_option(buf, "modifiable", False)
    nvim.api.buf_set_option(buf, "readonly", True)
    nvim.api.win_set_buf(win, buf)
    nvim.api.win_set_option(win, "wrap", True)
    nvim.api.win_set_option(win, "number", False)
    nvim.api.win_set_option(win, "relativenumber", False)
    nvim.api.win_set_option(win, "cursorline", False)
    nvim.api.win_set_option(win, "signcolumn", "no")
    nvim.api.buf_clear_namespace(buf, 0, 0, -1)

    # Initialize the indicator variable in Vim globals
    nvim.exec_lua("vim.g.user_entered = false")

    lua_code = """
    vim.g.prev_buf = ...
    function CloseMessageBuffer()
      vim.g.user_entered = true
      local bufnr = vim.api.nvim_get_current_buf()
      local prev_buf = vim.g.prev_buf
      if vim.api.nvim_buf_is_valid(prev_buf) then
        local win = vim.api.nvim_get_current_win()
        vim.api.nvim_win_set_buf(win, prev_buf)
      else
        local placeholder_buf = vim.api.nvim_create_buf(false, true)
        vim.api.nvim_buf_set_name(placeholder_buf, "[No Name]")
        local win = vim.api.nvim_get_current_win()
        vim.api.nvim_win_set_buf(win, placeholder_buf)
      end
      if vim.api.nvim_buf_is_valid(bufnr) then
        vim.api.nvim_buf_delete(bufnr, {force=true})
      end
    end
    """
    nvim.exec_lua(lua_code, prev_buf)

    nvim.api.buf_set_keymap(
        buf,
        "n",
        "<CR>",
        ":lua CloseMessageBuffer()<CR>",
        {"nowait": True, "noremap": True, "silent": True},
    )

    # Poll the variable until the user presses Enter
    while True:
        entered = nvim.exec_lua("return vim.g.user_entered")
        if entered:
            break
        time.sleep(0.1)
